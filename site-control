#!/usr/bin/env bash

SCRIPT_DIR="${HOME}/.scripts/site-control"

# Decoration ----------------------------------------------------------------------------
R='\033[0;31m'
G='\033[0;32m'
Y='\033[0;33m'
B='\033[0;34m'
M='\033[0;35m'
C='\033[0;36m'
NC='\033[0m'

banner() { printf "${M}============ ${B}%s ${M}============${NC} %s\n" "$1" "${2:+\n$2}"; }

ERR() { echo -e "${R}✗${NC} $1" >&2; }
OK() { echo -e "${G}✓${NC} $1"; }
WARN() { echo -e "${Y}WARNING: $1${NC}" >&2; }
TODO() { echo -e "${Y}TODO: $1${NC}" >&2; }
DEBUG() { echo -e "${C}DEBUG: ${B}$1${NC}" >&2; }

# Initialization -------------------------------------------------------------------------
script_init() {
    if [ -f "$REGISTRY" ]; then
        return 0;
    fi
    REGISTRY="${SCRIPT_DIR}/registry.yaml"
    if [[ ! -f "$REGISTRY" ]]; then
        ERR "Registry file missing from '${G}$REGISTRY${NC}'"
        echo "Unable to obtain global values."
        echo "Script will now exit..."
        exit 1
    fi
    if ! CFG_KEYS=$(yq e '.sites | keys[] | .' "$REGISTRY" 2>/dev/null); then
        WARN "No registered sites found."
    fi
}
script_init

# Helpers -------------------------------------------------------------------------------
has_local_config() {
    if [ -f "${PWD}/cfg.yaml" ]; then
        return 0;
    fi
    return 1;
}

has_script_config() {
    if [ -f "${REGISTRY}" ]; then
        return 0;
    fi
    return 1;
}

get_all_site_names() {
    echo "$CFG_KEYS"
}

get_version_info() {
    local path="$1"

    local prod_version; prod_version=$(
        git -C "$path" describe --abbrev=0 2>/dev/null || echo "unknown"
    )
    local dev_version; dev_version=$(
        git -C "$path" tag --sort=-version:refname | head -1 2>/dev/null || echo "unknown"
    )
    if [[ "$prod_version" == "unknown" && "$dev_version" != "unknown" ]]; then
        prod_version="$dev_version"
    fi

    local commits; commits=$(
        git -C "$path" rev-list --count main..HEAD 2>/dev/null || echo "0"
    )
    local current_branch; current_branch=$(
        git -C "$path" branch --show-current 2>/dev/null || echo "unknown"
    )

    echo "$prod_version|$dev_version|$commits|$current_branch"
}

update_version_info() {
    local site="$1"   
    local path; if ! path=$(yq e ".sites.${site}.root" "$REGISTRY"); then
        ERR "Updating version info failed: site root path not found"
    fi

    local vinfo; vinfo=$(get_version_info "$path")
    local vprod; vprod=$(echo "$vinfo" | cut -d'|' -f1)
    local vdev; vdev=$(echo "$vinfo" | cut -d'|' -f2)
    local commits; commits=$(echo "$vinfo" | cut -d'|' -f3)
    local branch; branch=$(echo "$vinfo" | cut -d'|' -f4)
    
    yq -i "with(.sites.${site};
        .dev_version = \"${vdev}\" |
        .prod_version = \"${vprod}\" |
        .commit_diff = ${commits} |
        .dev_branch = \"${branch}\"
    )" "${REGISTRY}"
}

update_timestamp() {
    local site; site="$1"
    local mode; mode="${2}"
    local timestamp; timestamp=$(date +'%d%b%Y %H:%M:%S')
    yq -i ".sites.${site}.last_${mode} = \"${timestamp}\"" "$REGISTRY"
}

# YAML ----------------------------------------------------------------------------------
get_and_incr_site_count() {
    local site_count=$((1 + $(yq e '.global.site_count' "$REGISTRY")))
    yq -i ".global.site_count = $site_count" "$REGISTRY"
    echo $site_count
}

make_local_config() {
    local site="$1"
    local local_cfg; local_cfg="${PWD}/cfg.yaml"
    touch "$local_cfg"
    local bport; bport=$(yq e ".sites.${site}.bport" "$REGISTRY")
    local fport; fport=$(yq e ".sites.${site}.fport" "$REGISTRY")
    read -r -p "Enter site description: " \
        -i "Webapp to..." -e description
    read -r -p "Enter repo URL: " \
        -i "http://github.com/theHousedev/" -e git_url
    yq -i "with(.;
        .tag = \"${site}\" |
        .name = \"${site^} Log\" |
        .description = \"${description}\" |
        .git_repo = \"${git_url}\" |
        .backend_port = \"${bport}\" |
        .frontend_port = \"${fport}\"
    )" "${local_cfg}"
    OK "Created local config file: $local_cfg"
}

register() {
    local site="$1"
    local index; index=$(get_and_incr_site_count)
    local bbase; bbase=$(yq e '.global.ports.backend' "$REGISTRY")
    local bport; bport=$((index + bbase))
    local fbase; fbase=$(yq e '.global.ports.frontend' "$REGISTRY")
    local fport; fport=$((index + fbase))
    local rootdir; rootdir=${PWD}

    yq -i "with(.sites.${site};
        .index = ${index} |
        .tag = \"${site}\" |
        .name = \"${site^} Log\" |
        .status = \"stopped\" |
        .fport = ${fport} |
        .bport = ${bport} |
        .root = \"${rootdir}\" |
        .fpath = \"${rootdir}/app\" |
        .bpath = \"${rootdir}/backend\" |
        .config = \"${rootdir}/cfg.yaml\" |
        .last_up = null |
        .last_dev = null |
        .session_name = \"dev-${site}\"
    )" "${REGISTRY}"

    update_version_info "$site"
}

sanity_check() {
    local site="$1"
    # pass $site into a sanity check function which will
        # look up $site in script registry
        # fetch root, fdir, bdir from registry
        # validate at least these dirs exist; else errmsg
        # check for .env in root
}

# Core Functions ------------------------------------------------------------------------
z() { # catch-all tester function
    local site; site="$1"
    update_version_info "$site"
    update_timestamp "$site" "up"
}

list() {
    TODO "list"
}

new() {
    local site="$1"
    if has_local_config; then
        ERR "Local config already exists"
        echo -e "Use '${G}site stats $site${NC}' to view details.\n" >&2;
        return 1;
    else
        if [ "$site" != "${PWD##*/}" ]; then
            ERR "'$site' is invalid - must match present dir name."
            read -nr 1 -p "  Proceed using pwd name '${PWD##*/}'? (y/n) " proceed
            echo ""
            case "$proceed" in
                y|Y|yes|YES) site="${PWD##*/}" ;;
                n|N|no|NO) echo -e "Quitting setup."; return 1; ;;
                *) echo -e "Invalid response, quitting setup."; return 1; ;;
            esac
        fi

        echo -e "Registering '$site'..."
        if ! register "$site"; then
            ERR "Failed to register site, aborting..."
            exit 1
        else
            OK "Successfully registered site"
        fi

        echo -e "Configuring '$site'..."
        if ! make_local_config "$site"; then
            ERR "Failed to create local config; aborting..."
            exit 1
        fi
    fi
}

dev() {
    local site="$1"
    if ! sanity_check "$site"; then exit 1; fi
    local cmd; cmd="${2:-run}" # "run" or "stop"
    local bpath; bpath=$(yq e ".sites.${site}.bpath" "$REGISTRY")
    local bport; bport=$(yq e ".sites.${site}.bport" "$REGISTRY")
    local fpath; fpath=$(yq e ".sites.${site}.fpath" "$REGISTRY")
    local fport; fport=$(yq e ".sites.${site}.fport" "$REGISTRY")
    local session; session=$(yq e ".sites.${site}.session_name" "$REGISTRY")

    if [[ "$cmd" == "stop" ]]; then
        echo -e "Stopping '${G}$session${NC}'...";

        if tmux has-session -t "$session" 2>/dev/null; then
            if tmux kill-session -t "$session" 2>/dev/null; then
                OK "Stopped session: '${G}$session${NC}'"
            else
                ERR "Unable to kill session: '${G}$session${NC}'"
                exit 1
            fi
        else
            WARN "No session found: '${G}$session${NC}'"
        fi
    else
        if tmux has-session -t "$session" 2>/dev/null; then
            echo -e "Found existing tmux session: '${G}$session${NC}'"
        else
            if ! tmux new-session -d -s "$session" \
                -e "ALLOWED_ORIGIN=http://10.0.0.8:$fport" 2>/dev/null; then
                ERR "Failed to start tmux session."
                exit 1
            fi
            tmux split-window -h -t "${session}"
            OK "Started new tmux session: '${G}$session${NC}'"
        fi

        if ! tmux send-keys -t "${session}:0.0" "cd ${bpath} && go run ." Enter; then
            ERR "Failed to start '${G}${session}${NC}' backend process."
            exit 1; fi
        OK "Backend service started"

        if ! tmux send-keys -t "${session}:0.1" "cd ${fpath} && npm run dev" Enter; then
            ERR "Failed to start '${G}${session}${NC}' frontend process."
            exit 1; fi
        OK "Frontend service started"

        # update last_dev
        update_timestamp "$site" "dev"
        
        # TODO: details, localhost url, how to attach to tmux session, etc.
    fi
}

deploy() {
    TODO "deploy"
    get_version_info "$PWD"
}

push() {
    TODO "push"
}

stats() {
    echo -e "Ordered names:\n  $(get_all_site_names)"
    echo "One-per-line:"
    for site in $CFG_KEYS; do
        echo "$site"
    done
}

logs() {
    TODO "logs"
}

help() {
    if [ "$1" == "short" ]; then
        echo -e "\nUsage: ${G}site <command> <site>${NC}"
        echo -e "Show all commands: '${G}site -h${NC}'\n"
        return 0;
    fi
    banner "Site Control Help"
    echo -e "Usage: ${G}site <command> <site>${NC}"
    echo -e "\nCommands:"
    echo -e "  ${G}help${NC}            Show this help message"
    echo -e "  ${G}list${NC}            List all sites"
    echo -e "  ${G}new <site>${NC}      Initialize a new site"
    echo -e "  ${G}dev <site>${NC}      Start a site in dev mode"
    echo -e "  ${G}deploy <site>${NC}   Deploy a live site"
    echo -e "  ${G}push <site>${NC}     Push a site to prod"
    echo -e "  ${G}stats <site>${NC}    Show stats for one (or all) sites"
    echo -e "  ${G}logs <site>${NC}     Show logs for one (or all) sites"
}

# main -----------------------------------------------------------------------------
main() {
    case "${1}" in
        new) new "$2";; list) list ;; -h|--help|help) help ;;
        dev) dev "$2" ;; stop) dev "$2" "stop" ;; deploy) deploy "$2" ;; push) push "$2";;
        stats) stats "$2" ;; logs) logs ;; z) z "$2";; *) help "short" ;;
    esac
}

main "$@"
